// Стандартная библиотека ввода/вывода
#include <iostream>

/*
 * Использование пространства имён std
 * (О пространствах имён будет позже.
 * если эту строчку не написать, то
 * придётся писать std::cout, std::endl
 * и т.д.
 */
using namespace std;

// Описываем структуру узла связного
// списка
struct Node
{
    // Хранимые данные
    // (могут быть чем угодно, не
    // только int
    int data;
    // Адрес следующего узла в списке
    Node *next;
};

/*
 * Функция создающая новый узел из данных
 * и добавляющая его в конец списка
 * head - указатель на голову (первый
 * элемент списка
 * d - данные
 */
void pushBackNode(Node *head, int d)
{
    /*
     * Создаём новый узел с данными d и
     * null адресом в качестве адреса
     * следующего узла, т.к. данный узел
     * будет последним и следующего за
     * ним пока нет. null адрес говорит
     * об отсутствии объекта, на который
     * указывает указатель. В Си и C++03
     * для этого использовался макрос NULL
     * (обычно #define NULL 0). В стандарте
     * C++11 было введено ключевое слово
     * nullptr, обозначающее то же самое,
     * но которое нельзя привести к типу
     * int, т.к. данное приведение может
     * приводить к ошибкам. При использовании
     * компилятора стандарта C++03 использовать
     * NULL вместо nullptr.
     */
    Node *tmp = new Node{d, nullptr};
    // Создаём указатель для прохода
    // по всему списку (можно было
    // использовать и head, просто для
    // более понятного кода).
    Node *currentNode = head;
    // Проходим по всем элементам списка
    while(currentNode->next != nullptr)
    {
        currentNode = currentNode->next;
    }

    // Устанавливаем в качестве адреса
    // следующего узла новый узел вместо
    // nullptr
    currentNode->next = tmp;
}

int main()
{
    // Создаём начало списка (голову)
    // с данными 0 и null адресом
    // следующего узла
    Node *head = new Node{0, nullptr};
    // Добавляем в конец новый узел с
    // данными 1
    pushBackNode(head, 1);
    // Выводим на экран данные следующего
    // за головой узла
    cout << head->next->data << endl;

    return 0;
}
